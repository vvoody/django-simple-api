# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['django_simple_api']

package_data = \
{'': ['*'], 'django_simple_api': ['templates/*']}

install_requires = \
['django', 'pydantic>=1.7.3,<2.0.0']

setup_kwargs = {
    'name': 'django-simple-api',
    'version': '0.1.0',
    'description': 'A non-intrusive component that can help you quickly create APIs.',
    'long_description': '# Django Simple API\n\nA non-intrusive component that can help you quickly create APIs.\n\n## Install\n\nDownload and install from github\n\n```\npip install git+https://github.com/abersheeran/django-simple-api.git@setup.py\n```\n\nAdd django-simple-api to your `INSTALLED_APPS` in settings:\n\n```python\nINSTALLED_APPS = [\n    ...\n    "django_simple_api",\n]\n```\n\nAdd `SimpleApiMiddleware` to your `MIDDLEWARE` in settings:\n\n```python\nMIDDLEWARE = [\n    ...\n    "django_simple_api.middleware.SimpleApiMiddleware",\n]\n```\n\n## Usage\n\n⚠️ We support both `view-function` and `class-view` at the same time for all functions. If there is no special description in the document, it means that it is applicable to both views. Where special support is needed, we will indicate how to do it in the document.\n\n### Parameter declaration and verification\n\nSimple API use `pydantic` to declare parameters and parameter verification.\n\nYou can declare request parameters like the following example:\n\n```python\n# views.py\nfrom django.views import View\nfrom django.http.response import HttpResponse\n\nfrom django_simple_api import Query\n\nclass JustTest(View):\n    def get(self, request, id: int = Query(...)):  \n        return HttpResponse(id)\n```\n\nSimple API has a total of 6 fields, corresponding to the parameters in different positions:\n\n##### All fields and description\n| Field     | Description |\n| ---       | ---         |\n| Query     | Indicates that this parameter is in the url query string. example: http://host/?param=1|\n| Path      | Indicates that this parameter is a url path parameter. example: http://host/{param}/|\n| Body      | Indicates that this parameter is in the request body, and the value can only be obtained in a non-GET request.|\n| Cookie    | Indicates that this parameter is in Cookie.|\n| Header    | Indicates that this parameter is in Header.|\n| Exclusive | This is a special field, its parameter annotation should be subclass of `pydantic.BaseModel`, it will get all the parameters from the location specified by `Exclusive`.\n\nFor example:\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass ArticleForm(BaseModel):\n    article_title: str = Field(...)\n    article_content: str = Field(...)\n\n\nclass JustTest(View):\n    # The parameter names used in the above examples are for demonstration only.\n    def post(self, request,\n            param1: int = Query(...),\n            param2: int = Query(...),\n            param3: int = Path(...),\n            # param4: str = Body(...),\n            userid: int = Cookie(..., alias="uid"),\n            csrf_token: str = Header(..., alias="X-CSRF-TOKEN"),\n    \n            # Simple API will get the `article_title` `article_content` parameter from the request body and create an object `article`\n            article: ArticleForm = Exclusive("body"),\n        ):\n\n        # You can get the parameters like this:\n        title = article.article_title\n        content = article.article_content\n\n        # Or directly convert to a dictionary:\n        d = article.dict()  # {"article_title": ..., "article_content": ...}\n        return HttpResponse(d)\n```\n\n⚠️ In the above example, you have two things to note:\n* When you need to get parameters from `Header`, you may need to use `alias` to indicate the request header you want to get, because the name of the request header may not be a valid python identifier.\n* When you use `Exclusive("body")` to get the form from a specified location, you can no longer use the `Body` field.\n\nAs you can see in the above example, Simple API also has the function of type conversion. If the parameter you pass in is legal for the declared type, it will be converted to the declared type without manual operation:\n\n```python\nclass JustTest(View):\n    def get(self, request, last_time: datetime.date = Query(...)):\n        print(last_time, type(last_time)) \n        # 2008-08-08 <class \'datetime.date\'> \n        return HttpResponse(last_time)\n```\n\nUse `Query(...)`  to declare the parameter, which means this parameter is required. If there is no `id` parameter in the query string for url, an error will be returned:\n\n```shell script\n[\n    {\n        "loc": [\n            "id"\n        ],\n        "msg": "field required",\n        "type": "value_error.missing"\n    }\n]\n```\n\nIn addition, you can use default parameters like this:\n\n```python\nclass JustTest(View):\n    def get(self, request, id: int = Query(10)):  \n        return HttpResponse(id)\n    # Or\n    def get(self, request, id: int = Query(None)):  \n        return HttpResponse(id)\n```\n\nOr you can use the `default_factory` parameter and pass in a function to dynamically calculate the default value:\n\n```python\ndef func():\n    return 1000\n\nclass JustTest(View):\n    def get(self, request, id: int = Query(default_factory=func)): \n        print(id)  # 1000\n        return HttpResponse(id)\n```\n\nBut you cannot use `default` and `default_factory` at the same time, otherwise an error will be reported:\n\n```shell script\nValueError: cannot specify both default and default_factory\n```\n\nIn addition to the `default`、`default_factory`, you can also use more attributes to constrain parameters, such as:\n\n```python\nclass JustTest(View):\n    # Use `const` to constrain the parameter value must be the same as the default value\n    def get(self, request, param: int = Query(10, const=True)):\n        print(param, type(param))\n        return HttpResponse(param)\n    \n    # If your parameter is of numeric type , you can use `ge`、`gt`、`le`、`lt`、`multipleOf` and other attributes\n    def get(self, request, \n            param1: int = Query(..., gt=10),  # must be > 10\n            param2: int = Query(..., ge=10),  # must be >= 10\n            param3: int = Query(..., lt=10),  # must be < 10\n            param4: int = Query(..., le=10),  # must be <= 10\n            param5: int = Query(..., multipleOf=10),  # must be a multiple of 10\n        ):\n        return HttpResponse(param)\n```\n\nAnd there are more attributes applied to `str` or `list` type, you can refer to the following table:\n\n#### Field parameter description\n| Name           | description |\n| ---            | ---         |\n| default        | since this is replacing the field’s default, its first argument is used to set the default, use ellipsis (``...``) to indicate the field is required|\n| default_factory| callable that will be called when a default value is needed for this field. If both `default` and `default_factory` are set, an error is raised.|\n| alias          | the public name of the field|\n| title          | can be any string, used in the schema|\n| description    | can be any string, used in the schema|\n| const          | this field is required and *must* take it\'s default value|\n| gt             | only applies to numbers, requires the field to be "greater than". The schema will have an ``exclusiveMinimum`` validation keyword|\n| ge             | only applies to numbers, requires the field to be "greater than or equal to". The schema will have a ``minimum`` validation keyword|\n| lt             | only applies to numbers, requires the field to be "less than". The schema will have an ``exclusiveMaximum`` validation keyword|\n| le             | only applies to numbers, requires the field to be "less than or equal to". The schema will have a ``maximum`` validation keyword|\n| multiple_of    | only applies to numbers, requires the field to be "a multiple of". The schema will have a ``multipleOf`` validation keyword|\n| min_items      | only applies to list or tuple and set, requires the field to have a minimum length.|\n| max_items      | only applies to list or tuple and set, requires the field to have a maximum length.|\n| min_length     | only applies to strings, requires the field to have a minimum length. The schema will have a ``maximum`` validation keyword|\n| max_length     | only applies to strings, requires the field to have a maximum length. The schema will have a ``maxLength`` validation keyword|\n| regex          | only applies to strings, requires the field match again a regular expression pattern string. The schema will have a ``pattern`` validation keyword|\n| extra          | any additional keyword arguments will be added as is to the schema|\n\nWhen you finish the above tutorial, you can already declare parameters well. If you have registered the `SimpleApiMiddleware` middleware, then all parameters will be automatically verified, and the detailed information of these parameters will be displayed in the interface document. The following will teach you how to generate the interface document.\n\n\n### Generate documentation\nIf you want to automatically generate interface documentation, you must add the url of Simple API to your url.py like this:\n```python\n# url.py\nfrom django.urls import include, path\nfrom django.conf import settings\n\n\n# Your urls\nurlpatterns = [\n    ...\n]\n\n# Simple API urls, should only run in a test environment.\nif settings.DEBUG:\n    urlpatterns += [\n        # generate documentation\n        path(\n            "docs/",\n            include("django_simple_api.urls"),\n            {\n                "template_name": "swagger.html",\n                "title": "Django Simple API",\n                "description": "This is description of your interface document.",\n                "version": "0.1.0",\n            },\n        ),\n    ]\n```\n\nIn the above example, you can modify the `template_name` to change the UI theme of the interface document, We currently have two UI themes: `swagger.html` and `redoc.html`. \n\nAnd then you can modify `title`、`description` and `version` to describe your interface documentation.\n\nIf you are using `class-view`, you can now generate documentation. Start your service, if your service is running locally, you can visit http://127.0.0.1:8000/docs/ to view your documentation.\n\nBut if you are using `view-function`, you must declare the request method supported by the view function:\n\n```python\n# views.py\nfrom django_simple_api import allow_request_method\n\n@allow_request_method("get")\ndef just_test(request, id: int = Query(...)):\n    return HttpResponse(id)\n```\n\n`allow_request_method` can only declare one request method, and it must be in `[\'get\', \'post\', \'put\', \'patch\', \'delete\', \'head\', \'trace\']`. \nWe do not support the behavior of using multiple request methods in a `view-function`, which will cause trouble for generating documentation.\n\nNote that if you use `@allow_request_method("get")` to declare a request method, you will not be able to use request methods other than `get`, otherwise it will return `405 Method Not Allow`.\n\nYou can also not use `allow_request_method`, this will not have any negative effects, but it will not generate documentation.\nWe will use `warning.warn()` to remind you, this is not a problem, just to prevent you from forgetting to use it.\n\nNow, the view function can also generate documents, you can continue to visit your server to view the effect.\n',
    'author': 'abersheeran',
    'author_email': 'me@abersheeran.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/abersheeran/django-simple-api',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)

